function R = GraphBeamforming_Main(Pin)
    P = getDefaultParams();
    if nargin > 0 && ~isempty(Pin)
        P = overrideParams(P, Pin);
    end
    P = addGraphParams(P);
    
    if ~isempty(P.seed)
        rng(P.seed, 'twister');
    end
    
    rngState = rng;
    
    [Rs_orig, Ri_orig] = computeCovMatrices(P);
    w_original = computeGEVFromCov(Rs_orig, Ri_orig, P.sigma2, P.alphaDL);
    
    G = learnCouplingGraph(P);
    [Rs_graph, Ri_graph] = computeGraphCovMatrices(P, G);
    L = computeGraphLaplacian(G);
    w_graph = solveGraphBeamforming(L, Rs_graph, Ri_graph, P);
    
    rng(rngState);
    sinr_orig = evaluateSINR(P, w_original);
    rng(rngState);
    sinr_graph = evaluateSINR(P, w_graph);
    
    R.original.meanSINR_dB = mean(10*log10(max(real(sinr_orig), realmin)));
    R.original.stdSINR_dB = std(10*log10(max(real(sinr_orig), realmin)));
    R.graph.meanSINR_dB = mean(10*log10(max(real(sinr_graph), realmin)));
    R.graph.stdSINR_dB = std(10*log10(max(real(sinr_graph), realmin)));
    
    R.w_original = w_original;
    R.w_graph = w_graph;
    R.G = G;
    R.L = L;
    R.params = P;
    
    R.interference = analyseInterferencePropagation(G, w_graph, P);
    R.interference.baseline = analyseInterferencePropagation(zeros(P.N), w_original, P);
    
    plotResults(R, P);
    
    fprintf('\n=== PERFORMANCE SUMMARY ===\n');
    fprintf('Baseline:          %.2f ± %.2f dB\n', R.original.meanSINR_dB, R.original.stdSINR_dB);
    fprintf('Graph-Regularized: %.2f ± %.2f dB\n', R.graph.meanSINR_dB, R.graph.stdSINR_dB);
    fprintf('SINR Trade-off:    %.2f dB\n', R.graph.meanSINR_dB - R.original.meanSINR_dB);
    fprintf('Interference Spreading: %.3f (%.0f%% reduction)\n', ...
        R.interference.spread, (1 - R.interference.spread/R.interference.baseline.spread)*100);
end

function P = getDefaultParams()
    P.N = 128;
    P.lambda = 1;
    P.d = P.lambda/2;
    P.U = 2;
    P.I = 3;
    P.desiredUserIdx = 1;
    P.theta_users_deg = [-10 20];
    P.theta_interfs_deg = [-50 40 65];
    P.Pu = ones(1, P.U);
    P.Pi = ones(1, P.I);
    P.sigma2 = 1e-3;
    P.alphaDL = 1e-3;
    P.iter = 1000;
    P.numPaths = 3;
    P.phaseNoiseStd = 0.05;
    P.pathAngleStd = 1;
    P.couplingCoeff = 0.05;
    P.seed = 0;
end

function P = addGraphParams(P)
    P.maxCoupling = 0.05;
    P.couplingDecayRate = 0.1;
    P.graphReg = 1e-4;
    P.sparsityThreshold = 1e-5;
    P.propagationFactor = 0.3;
    P.propagationSteps = 20;
end

function P = overrideParams(P, A)
    fn = fieldnames(A);
    for k = 1:numel(fn)
        P.(fn{k}) = A.(fn{k});
    end
end

function G = learnCouplingGraph(P)
    N = P.N;
    correlations = measureArrayCorrelations(P);
    maxCorr = max(correlations(:));
    if maxCorr <= 0
        maxCorr = 1;
    end
    correlations = correlations / maxCorr;
    
    G = zeros(N);
    for i = 1:N
        for j = i+1:N
            g_stat = P.maxCoupling * max(correlations(i,j), 0);
            g_phys = P.maxCoupling * exp(-P.couplingDecayRate * abs(i - j));
            g_ij = min(g_stat, g_phys);
            if g_ij < P.sparsityThreshold
                g_ij = 0;
            end
            G(i,j) = g_ij;
            G(j,i) = g_ij;
        end
    end
    G(1:N+1:end) = 0;
end

function C = measureArrayCorrelations(P)
    [Rs, Ri] = computeCovMatrices(P);
    C = abs(Rs + Ri);
end

function w = solveGraphBeamforming(L, Rs, Ri, P)
    N = size(Rs,1);
    mu = P.graphReg;
    
    Rs_sym = (Rs + Rs')/2;
    Rin = (Ri + Ri')/2;
    Rin = Rin + P.sigma2*eye(N) + mu * L + P.alphaDL * (trace(Ri)/N) * eye(N);
    Rin = (Rin + Rin')/2;
    
    [V,D] = eig(Rs_sym, Rin, 'vector');
    [~,ix] = max(real(D));
    w = V(:, ix);
    w = w / norm(w);
end

function L = computeGraphLaplacian(G)
    deg = sum(G, 2);
    L = diag(deg) - G;
end

function [Rs_graph, Ri_graph] = computeGraphCovMatrices(P, G)
    [Rs, Ri] = computeCovMatrices(P);
    N = size(G, 1);
    I = eye(N);
    coupling = I + G;
    Rs_graph = coupling * Rs * coupling';
    Ri_graph = coupling * Ri * coupling';
    Rs_graph = (Rs_graph + Rs_graph')/2;
    Ri_graph = (Ri_graph + Ri_graph')/2;
end

function interference = analyseInterferencePropagation(G, w, P)
    N = P.N;
    I0 = abs(w(:)).^2;
    I_history = zeros(N, P.propagationSteps);
    I = I0;
    
    for t = 1:P.propagationSteps
        I_new = P.propagationFactor * (G * I) + (1 - P.propagationFactor) * I0;
        I_history(:, t) = I_new;
        I = I_new;
    end
    
    interference.initial = I0;
    interference.final = I;
    interference.history = I_history;
    interference.spread = norm(I - I0) / max(norm(I0), eps);
end

function plotResults(R, P)
    figure(1);
    theta = -90:0.5:90;
    B_orig = computeBeamPattern(R.w_original, theta, P);
    B_graph = computeBeamPattern(R.w_graph, theta, P);
    
    plot(theta, B_orig, 'b-', 'LineWidth', 1.5); hold on;
    plot(theta, B_graph, 'r--', 'LineWidth', 1.5);
    plot(P.theta_users_deg(P.desiredUserIdx), 0, 'go', 'MarkerSize', 10, 'MarkerFaceColor','g');
    plot(P.theta_interfs_deg, -25*ones(1, P.I), 'rv', 'MarkerSize', 8, 'MarkerFaceColor','r');
    
    grid on;
    xlim([-90 90]); 
    ylim([-60 5]);
    xlabel('Angle (degrees)');
    ylabel('Gain (dB)');
    title('Beam Pattern Comparison');
    legend({'Baseline','Graph-Regularized','Desired User','Interferers'}, 'Location','best');
    
    figure(2);
    imagesc(R.G);
    colorbar;
    colormap(jet);
    xlabel('Antenna Index');
    ylabel('Antenna Index');
    title('Learned Coupling Graph via Dual-Criterion Algorithm');
    
    figure(3);
    imagesc(R.interference.history);
    colorbar;
    colormap(hot);
    xlabel('Time Step');
    ylabel('Antenna Index');
    title(sprintf('Interference Propagation (\\xi = %.3f)', R.interference.spread));
end

function B = computeBeamPattern(w, theta, P)
    N = length(w);
    B = zeros(size(theta));
    
    for i = 1:numel(theta)
        a = steeringVector(theta(i), N, P.d, P.lambda);
        B(i) = abs(w' * a);
    end
    
    maxB = max(B);
    if maxB <= 0
        maxB = eps;
    end
    B = 20*log10(B / maxB);
end

function [Rs, Ri] = computeCovMatrices(P)
    N = P.N;
    idx = P.desiredUserIdx;
    Pu = P.Pu;
    Pi = P.Pi;
    
    baseP = exp(-0.5 * (0:P.numPaths-1)');
    baseP = baseP / sum(baseP);
    
    ths = P.theta_users_deg(idx) + P.pathAngleStd * randn(P.numPaths,1);
    Smp = zeros(N, P.numPaths);
    for p = 1:P.numPaths
        Smp(:, p) = steeringVector(ths(p), N, P.d, P.lambda);
    end
    Rs = Pu(idx) * (Smp * diag(baseP) * Smp');
    
    Ri = zeros(N);
    otherU = setdiff(1:P.U, idx);
    for u = otherU
        ths = P.theta_users_deg(u) + P.pathAngleStd * randn(P.numPaths,1);
        for p = 1:P.numPaths
            Smp(:, p) = steeringVector(ths(p), N, P.d, P.lambda);
        end
        Ri = Ri + Pu(u) * (Smp * diag(baseP) * Smp');
    end
    
    for k = 1:P.I
        ths = P.theta_interfs_deg(k) + P.pathAngleStd * randn(P.numPaths,1);
        for p = 1:P.numPaths
            Smp(:, p) = steeringVector(ths(p), N, P.d, P.lambda);
        end
        Ri = Ri + Pi(k) * (Smp * diag(baseP) * Smp');
    end
    
    if P.couplingCoeff ~= 0
        C = eye(N) + P.couplingCoeff * (diag(ones(N-1,1),1) + diag(ones(N-1,1),-1));
        Rs = C * Rs * C';
        Ri = C * Ri * C';
    end
    
    Rs = (Rs + Rs')/2;
    Ri = (Ri + Ri')/2;
end

function w = computeGEVFromCov(Rs, Ri, sigma2, alpha)
    N = size(Rs,1);
    Rin = Ri + sigma2 * eye(N) + alpha * (trace(Ri)/N) * eye(N);
    Rin = (Rin + Rin')/2;
    Rs = (Rs + Rs')/2;
    
    [V,D] = eig(Rs, Rin, 'vector');
    [~, ix] = max(real(D));
    w = V(:, ix);
    w = w / norm(w);
end

function sinr_all = evaluateSINR(P, w)
    N = P.N;
    U = P.U;
    I = P.I;
    L = P.iter;
    idx = P.desiredUserIdx;
    
    sinr_all = nan(L,1);
    C = eye(N) + P.couplingCoeff * (diag(ones(N-1,1),1) + diag(ones(N-1,1),-1));
    
    for t = 1:L
        th_u = P.theta_users_deg;
        th_i = P.theta_interfs_deg;
        
        Hu = zeros(N, U);
        Hi = zeros(N, I);
        
        for u = 1:U
            Hu(:, u) = channelVector(N, th_u(u), P, C);
        end
        
        for k = 1:I
            Hi(:, k) = channelVector(N, th_i(k), P, C);
        end
        
        Sd = Hu(:, idx);
        sig = P.Pu(idx) * abs(w' * Sd)^2;
        
        interferersU = setdiff(1:U, idx);
        interfU = sum(P.Pu(interferersU) .* abs(w' * Hu(:, interferersU)).^2);
        interfI = sum(P.Pi .* abs(w' * Hi).^2);
        
        sinr_all(t) = sig / (interfU + interfI + P.sigma2);
    end
end

function s = steeringVector(theta, N, d, lambda)
    theta = max(min(theta, 90), -90);
    phi = -1i * 2 * pi * d * (0:N-1).' * sind(theta) / lambda;
    s = exp(phi) / sqrt(N);
end

function h = channelVector(N, theta, P, C)
    np = P.numPaths;
    pn = P.phaseNoiseStd;
    d = P.d;
    lam = P.lambda;
    stdA = P.pathAngleStd;
    
    h_sum = zeros(N,1);
    for p = 1:np
        th = theta + stdA * randn();
        a = steeringVector(th, N, d, lam);
        phn = exp(1i * pn * randn(N,1));
        h_sum = h_sum + a .* phn;
    end
    h = C * (h_sum / sqrt(np));
end

function R = MU_BF_GEV(Pin)
P = getDefaultParams();
if nargin>0
    P = overrideParams(P,Pin);
end
if ~isempty(P.seed)
    rng(P.seed,'twister');
end

Su = computeSteeringMatrix(P.theta_users_deg,P.N,P.d,P.lambda);
Si = computeSteeringMatrix(P.theta_interfs_deg,P.N,P.d,P.lambda);

w_opt = computeGEVBeamformer(Su,Si,P.Pu,P.Pi,P.sigma2,P.alphaDL,P.desiredUserIdx);

if P.plotBeam
    plotBeamPattern(w_opt,P.N,P.d,P.lambda,P.theta_users_deg,P.theta_interfs_deg,P.desiredUserIdx);
end

[sinr_all,sinr_users] = runMonteCarlo(P);
sinr_all  = max(sinr_all, realmin);
sinr_users = max(sinr_users, realmin);

R.meanSINR_dB   = mean(10*log10(sinr_all));
R.stdSINR_dB    = std(10*log10(sinr_all));
R.minSINR_dB    = min(10*log10(sinr_all));
R.maxSINR_dB    = max(10*log10(sinr_all));
R.SINR_dB_all   = 10*log10(sinr_all);
R.SINR_users_dB = 10*log10(sinr_users);
R.w_opt         = w_opt;
R.params        = P;
end

function P = getDefaultParams()
P.N               = 128;
P.lambda          = 1;
P.d               = P.lambda/2;
P.U               = 2;
P.I               = 3;
P.desiredUserIdx  = 1;
P.theta_users_deg   = [-10 20];
P.theta_interfs_deg = [-50 40 65];
P.Pu              = ones(1,P.U);
P.Pi              = ones(1,P.I);
P.sigma2          = 1e-2;
P.noiseJitterFrac = 0.2;
P.alphaDL         = 1e-2;
P.iter            = 1000;
P.angleStdUser    = 5;
P.angleStdInt     = 5;
P.numPaths        = 3;
P.phaseNoiseStd   = 0.1;
P.couplingCoeff   = 0.1;
P.plotBeam        = true;
P.showProg        = true;
P.seed            = 0;
end

function P = overrideParams(P,A)
f = fieldnames(A);
for k=1:numel(f)
    P.(f{k}) = A.(f{k});
end
end

function S = computeSteeringMatrix(angles,N,d,lambda)
S = zeros(N,numel(angles));
for k=1:numel(angles)
    S(:,k) = steeringVector(angles(k),N,d,lambda);
end
end

function s = steeringVector(theta,N,d,lambda)
theta = max(min(theta,90),-90);
phi   = -1i*2*pi*d*(0:N-1).' * sind(theta)/lambda;
s     = exp(phi);
s     = s/norm(s);
end

function w = computeGEVBeamformer(Su,Si,Pu,Pi,sigma2,alpha,idx)
N   = size(Su,1);
v0  = sqrt(Pu(idx))*Su(:,idx);
Rs  = v0*v0';
Ri  = zeros(N);
oth = setdiff(1:size(Su,2),idx);
for u=oth
    v      = sqrt(Pu(u))*Su(:,u);
    Ri     = Ri + v*v';
end
for k=1:size(Si,2)
    g      = sqrt(Pi(k))*Si(:,k);
    Ri     = Ri + g*g';
end
Rin = Ri + sigma2*eye(N) + alpha*(trace(Ri)/N)*eye(N);
[V,D] = eig(Rs,Rin,'vector');
[~,ix] = max(real(D));
w     = V(:,ix);
w     = w/norm(w);
end

function [sinr_all,sinr_users] = runMonteCarlo(P)
N = P.N; U = P.U; I = P.I; L = P.iter; idx = P.desiredUserIdx;
sinr_all   = nan(L,1);
sinr_users = nan(U,L);
C = eye(N) + P.couplingCoeff*(diag(ones(N-1,1),1)+diag(ones(N-1,1),-1));
step = max(1,floor(L/10));
for t=1:L
    if P.showProg && mod(t,step)==0
        fprintf('%.0f%%\n',100*t/L);
    end
    th_u = P.theta_users_deg + P.angleStdUser*randn(1,U);
    th_i = P.theta_interfs_deg + P.angleStdInt*randn(1,I);
    Hu = zeros(N,U);
    Hi = zeros(N,I);
    for u=1:U
        Hu(:,u) = channelVector(N,th_u(u),P,C);
    end
    for k=1:I
        Hi(:,k) = channelVector(N,th_i(k),P,C);
    end
    Sd      = Hu(:,idx);
    Su_oth  = Hu(:,setdiff(1:U,idx));
    w       = computeGEVBeamformer(Hu,Hi,P.Pu,P.Pi,P.sigma2,P.alphaDL,idx);
    sig     = P.Pu(idx)*abs(w'*Sd)^2;
    interfU = sum(P.Pu(setdiff(1:U,idx)).*abs(w'*Su_oth).^2);
    interfI = sum(P.Pi.*abs(w'*Hi).^2);
    sigma_n = max(P.sigma2*(1+P.noiseJitterFrac*randn()),realmin);
    sinr_all(t) = sig/(interfU + interfI + sigma_n);
    for u=1:U
        sig_u       = P.Pu(u)*abs(w'*Hu(:,u))^2;
        tmp         = setdiff(1:U,u);
        interf_uU   = sum(P.Pu(tmp).*abs(w'*Hu(:,tmp)).^2);
        interf_uI   = sum(P.Pi.*abs(w'*Hi).^2);
        sinr_users(u,t) = sig_u/(interf_uU + interf_uI + sigma_n);
    end
end
end

function h = channelVector(N,theta,P,C)
np     = P.numPaths;
pn     = P.phaseNoiseStd;
d      = P.d;
lambda = P.lambda;
h_sum  = zeros(N,1);
for p=1:np
    th   = theta + 2*randn();
    a    = steeringVector(th,N,d,lambda);
    fad  = (randn()+1i*randn())/sqrt(2);
    phn  = exp(1i*pn*randn(N,1));
    h_sum = h_sum + fad.*(a.*phn);
end
h = C*h_sum;
end

function plotBeamPattern(w,N,d,lambda,thetaU,thetaI,idx)
th = -90:0.1:90;
B  = arrayfun(@(x) abs(w'*steeringVector(x,N,d,lambda)),th);
B  = 20*log10(B/max(B));
figure('Name','Beam Pattern');
plot(th,B,'LineWidth',1.2);
grid on; xlim([-90 90]); ylim([-60 0]); hold on
plot(thetaU(idx),-3,'go','MarkerSize',10,'MarkerFaceColor','g')
oth = setdiff(1:numel(thetaU),idx);
if ~isempty(oth)
    plot(thetaU(oth),-3*ones(size(oth)),'b^','MarkerSize',8)
end
plot(thetaI,-20*ones(size(thetaI)),'rv','MarkerSize',8)
xlabel('Angle (deg)'); ylabel('Gain (dB)'); title('Max-SINR Beam')
if isempty(oth)
    legend('|w^H s(\theta)| (dB)','Desired user','Interferers','Location','best')
else
    legend('|w^H s(\theta)| (dB)','Desired user','Other users','Interferers','Location','best')
end
hold off
end

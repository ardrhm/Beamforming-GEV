function R = MU_BF_GEV(Pin)
P = getDefaultParams();
if nargin>0, P = overrideParams(P,Pin); end
if ~isempty(P.seed), rng(P.seed,'twister'); end
assert(numel(P.Pu)==P.U,'Length of Pu must equal P.U');
assert(numel(P.Pi)==P.I,'Length of Pi must equal P.I');
assert(P.desiredUserIdx>=1 && P.desiredUserIdx<=P.U,'desiredUserIdx out of range');
rngState = rng;
[Rs,Ri] = computeCovMatrices(P);
rng(rngState);
w_opt = computeGEVFromCov(Rs,Ri,P.sigma2,P.alphaDL);
if P.plotBeam
    plotBeamPattern(w_opt,P.N,P.d,P.lambda,P.theta_users_deg,P.theta_interfs_deg,P.desiredUserIdx);
end
[sinr_all,sinr_users] = evaluateSINRMonteCarlo(P,w_opt);
sinr_all   = max(sinr_all,realmin);
sinr_users = max(sinr_users,realmin);
R.meanSINR_dB   = mean(10*log10(sinr_all));
R.stdSINR_dB    = std(10*log10(sinr_all));
R.minSINR_dB    = min(10*log10(sinr_all));
R.maxSINR_dB    = max(10*log10(sinr_all));
R.SINR_dB_all   = 10*log10(sinr_all);
R.SINR_users_dB = 10*log10(sinr_users);
R.w_opt         = w_opt;
R.params        = P;
end

function P = getDefaultParams()
P.N = 128;
P.lambda = 1;
P.d = P.lambda/2;
P.U = 2;
P.I = 3;
P.desiredUserIdx = 1;
P.theta_users_deg = [-10 20];
P.theta_interfs_deg = [-50 40 65];
P.Pu = ones(1,P.U);
P.Pi = ones(1,P.I);
P.sigma2 = 1e-2;
P.noiseJitterFrac = 0.2;
P.alphaDL = 1e-2;
P.iter = 1000;
P.angleStdUser = 0;
P.angleStdInt = 0;
P.numPaths = 3;
P.phaseNoiseStd = 0.1;
P.pathAngleStd = 2;
P.couplingCoeff = 0.1;
P.plotBeam = true;
P.showProg = true;
P.seed = 0;
end

function P = overrideParams(P,A)
f = fieldnames(A);
for k=1:numel(f), P.(f{k}) = A.(f{k}); end
end

function [Rs,Ri] = computeCovMatrices(P)
N = P.N; idx = P.desiredUserIdx; Pu = P.Pu; Pi = P.Pi;
baseP = exp(-0.5*(0:P.numPaths-1)'); baseP = baseP/sum(baseP);
ths = P.theta_users_deg(idx) + P.pathAngleStd*randn(P.numPaths,1);
Smp = zeros(N,P.numPaths);
for p=1:P.numPaths, Smp(:,p) = steeringVector(ths(p),N,P.d,P.lambda); end
Rs = Pu(idx)*(Smp*diag(baseP)*Smp');
Ri = zeros(N);
otherU = setdiff(1:P.U,idx);
for u = otherU
    ths = P.theta_users_deg(u) + P.pathAngleStd*randn(P.numPaths,1);
    for p=1:P.numPaths, Smp(:,p) = steeringVector(ths(p),N,P.d,P.lambda); end
    Ri = Ri + Pu(u)*(Smp*diag(baseP)*Smp');
end
for k=1:P.I
    ths = P.theta_interfs_deg(k) + P.pathAngleStd*randn(P.numPaths,1);
    for p=1:P.numPaths, Smp(:,p) = steeringVector(ths(p),N,P.d,P.lambda); end
    Ri = Ri + Pi(k)*(Smp*diag(baseP)*Smp');
end
if P.couplingCoeff~=0
    C = eye(N) + P.couplingCoeff*(diag(ones(N-1,1),1)+diag(ones(N-1,1),-1));
    Rs = C*Rs*C';
    Ri = C*Ri*C';
end
Rs = (Rs+Rs')/2;
Ri = (Ri+Ri')/2;
end

function w = computeGEVFromCov(Rs,Ri,sigma2,alpha)
N = size(Rs,1);
Rin = Ri + sigma2*eye(N) + alpha*(trace(Ri)/N)*eye(N);
Rin = (Rin+Rin')/2;
if N<=200
    [V,D] = eig(Rs,Rin,'vector');
    [~,ix] = max(real(D));
    w = V(:,ix);
else
    w = eigs(Rs,Rin,1,'largestreal');
end
w = w/norm(w);
end

function [sinr_all,sinr_users] = evaluateSINRMonteCarlo(P,w)
N = P.N; U = P.U; I = P.I; L = P.iter; idx = P.desiredUserIdx;
sinr_all = nan(L,1);
sinr_users = nan(U,L);
C = eye(N) + P.couplingCoeff*(diag(ones(N-1,1),1)+diag(ones(N-1,1),-1));
if P.showProg, fprintf('Progress:   0%%'); end
step = max(1,round(L/20));
for t=1:L
    if P.showProg && (t==1 || t==L || mod(t,step)==0), fprintf('\rProgress: %3.0f%%',100*t/L); end
    th_u = P.theta_users_deg + P.angleStdUser*randn(1,U);
    th_i = P.theta_interfs_deg + P.angleStdInt*randn(1,I);
    Hu = zeros(N,U); Hi = zeros(N,I);
    for u=1:U, Hu(:,u)=channelVector(N,th_u(u),P,C); end
    for k=1:I, Hi(:,k)=channelVector(N,th_i(k),P,C); end
    Sd      = Hu(:,idx);
    sig     = P.Pu(idx)*abs(w'*Sd)^2;
    interfU = sum(P.Pu(setdiff(1:U,idx)) .* abs(w'*Hu(:,setdiff(1:U,idx))).^2);
    interfI = sum(P.Pi .* abs(w'*Hi).^2);
    sigma_n = P.sigma2 * max(1 + P.noiseJitterFrac*randn(), 0);
    sinr_all(t) = sig/(interfU + interfI + sigma_n);
    for u=1:U
        interferers = setdiff(1:U,u);
        sig_u       = P.Pu(u)*abs(w'*Hu(:,u))^2;
        interf_uU   = sum(P.Pu(interferers) .* abs(w'*Hu(:,interferers)).^2);
        sinr_users(u,t) = sig_u/(interf_uU + interfI + sigma_n);
    end
end
if P.showProg, fprintf('\n'); end
end

function s = steeringVector(theta,N,d,lambda)
theta = max(min(theta,90),-90);
phi = -1i*2*pi*d*(0:N-1).' * sind(theta)/lambda;
s = exp(phi);
s = s/norm(s);
end

function h = channelVector(N,theta,P,C)
np = P.numPaths; pn = P.phaseNoiseStd; d = P.d; lam = P.lambda; stdA = P.pathAngleStd;
h_sum = zeros(N,1);
for p=1:np
    th = theta + stdA*randn();
    a  = steeringVector(th,N,d,lam);
    phn = exp(1i*pn*randn(N,1));
    h_sum = h_sum + a.*phn;
end
h = C*(h_sum/max(sqrt(np),1));
end

function plotBeamPattern(w,N,d,lambda,thetaU,thetaI,idx)
th = -90:0.1:90;
B = arrayfun(@(x) abs(w'*steeringVector(x,N,d,lambda)),th);
B = 20*log10(B/max(B));
figure; plot(th,B,'LineWidth',1.2); grid on; xlim([-90 90]); ylim([-60 0]); hold on
plot(thetaU(idx),-3,'go','MarkerSize',10,'MarkerFaceColor','g');
oth = setdiff(1:numel(thetaU),idx);
if ~isempty(oth), plot(thetaU(oth),-3*ones(size(oth)),'b^','MarkerSize',8); end
plot(thetaI,-20*ones(size(thetaI)),'rv','MarkerSize',8);
[~,ix] = max(B); plot(th(ix),B(ix),'gs','MarkerSize',10,'MarkerFaceColor','g');
xlabel('Angle (deg)'); ylabel('Gain (dB)'); title('Max-SINR Beam');
if isempty(oth)
    legend('|w^H s(\\theta)| (dB)','Desired user','Interferers','Beam peak','Location','best');
else
    legend('|w^H s(\\theta)| (dB)','Desired user','Other users','Interferers','Beam peak','Location','best');
end
hold off
end
